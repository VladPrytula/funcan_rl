[[Day_5#]]

# Week 1, Day 5 Exercises: Synthesis and Computational Verification

This document contains exercises synthesizing Week 1 concepts through theoretical problems and computational implementations.

---

## **Exercise 1: Ï€-Î» Theorem Application**

**Statement (Anchor Exercise 1 from Day 1):** Let $\mathcal{P}$ be a Ï€-system on $X$ (closed under finite intersections) and $\mathcal{L}$ be a Î»-system on $X$ (contains $X$, closed under complements and countable disjoint unions). Prove that if $\mathcal{P} \subseteq \mathcal{L}$, then $\sigma(\mathcal{P}) \subseteq \mathcal{L}$.

**Proof:**

**Definitions Recap:**
- **Ï€-system:** $\mathcal{P}$ is a Ï€-system if $A, B \in \mathcal{P} \Rightarrow A \cap B \in \mathcal{P}$
- **Î»-system:** $\mathcal{L}$ is a Î»-system if:
  1. $X \in \mathcal{L}$
  2. If $A \in \mathcal{L}$, then $A^c \in \mathcal{L}$
  3. If $\{A_n\}$ are pairwise disjoint and each $A_n \in \mathcal{L}$, then $\bigcup A_n \in \mathcal{L}$

**Key Lemma (Dynkin's Ï€-Î» Theorem):** If $\mathcal{P}$ is a Ï€-system and $\mathcal{L}$ is a Î»-system with $\mathcal{P} \subseteq \mathcal{L}$, then $\sigma(\mathcal{P}) \subseteq \mathcal{L}$.

**Strategy:** We will show that the smallest Î»-system containing $\mathcal{P}$, denoted $\lambda(\mathcal{P})$, is actually a Ïƒ-algebra. Since $\mathcal{L}$ is a Î»-system containing $\mathcal{P}$, we have $\lambda(\mathcal{P}) \subseteq \mathcal{L}$. Since $\lambda(\mathcal{P})$ is a Ïƒ-algebra, it contains $\sigma(\mathcal{P})$, and thus $\sigma(\mathcal{P}) \subseteq \mathcal{L}$.

**Step 1: Define the smallest Î»-system containing $\mathcal{P}$.**

Let $\lambda(\mathcal{P})$ denote the intersection of all Î»-systems containing $\mathcal{P}$. This is the **smallest Î»-system** containing $\mathcal{P}$ (the intersection of Î»-systems is a Î»-system).

Since $\mathcal{L}$ is a Î»-system containing $\mathcal{P}$:
$$
\lambda(\mathcal{P}) \subseteq \mathcal{L}
$$

**Step 2: Show that $\lambda(\mathcal{P})$ is a Ïƒ-algebra.**

A Î»-system is a Ïƒ-algebra if and only if it is closed under finite intersections (this is a standard result; see Folland Theorem 1.2).

We will prove that $\lambda(\mathcal{P})$ is closed under finite intersections, leveraging the fact that $\mathcal{P}$ is a Ï€-system.

**Sub-step 2a: For any $A \in \lambda(\mathcal{P})$, define:**
$$
\mathcal{L}_A = \{B \in \lambda(\mathcal{P}) : A \cap B \in \lambda(\mathcal{P})\}
$$

We claim that $\mathcal{L}_A$ is a Î»-system.

**Verification:**
1. **$X \in \mathcal{L}_A$:** We have $A \cap X = A \in \lambda(\mathcal{P})$, so $X \in \mathcal{L}_A$.

2. **Closed under complements:** If $B \in \mathcal{L}_A$, then $A \cap B \in \lambda(\mathcal{P})$. We must show $B^c \in \mathcal{L}_A$, i.e., $A \cap B^c \in \lambda(\mathcal{P})$.

   Note that
   $$
   A \cap B^c = A \setminus (A \cap B),
   $$
   and $A \cap B \subseteq A$. A standard property of Î»-systems is: if $C, D \in \mathcal{L}$ with $C \subseteq D$, then $D \setminus C \in \mathcal{L}$. Applying this with $C = A \cap B$ and $D = A$ yields $A \setminus (A \cap B) \in \lambda(\mathcal{P})$. Hence $A \cap B^c \in \lambda(\mathcal{P})$, so $B^c \in \mathcal{L}_A$.

3. **Closed under countable disjoint unions:** If $\{B_n\}$ are pairwise disjoint sets in $\mathcal{L}_A$, then $A \cap B_n \in \lambda(\mathcal{P})$ for each $n$, and the sets $\{A \cap B_n\}$ are pairwise disjoint. Since $\lambda(\mathcal{P})$ is a Î»-system:
   $$
   \bigcup_{n=1}^{\infty} (A \cap B_n) = A \cap \left(\bigcup_{n=1}^{\infty} B_n\right) \in \lambda(\mathcal{P})
   $$
   Thus $\bigcup B_n \in \mathcal{L}_A$.

Therefore, $\mathcal{L}_A$ is a Î»-system.

**Sub-step 2b: For any $P \in \mathcal{P}$, we have $\mathcal{P} \subseteq \mathcal{L}_P$.**

Fix $P \in \mathcal{P}$. For any $Q \in \mathcal{P}$, since $\mathcal{P}$ is a Ï€-system, $P \cap Q \in \mathcal{P} \subseteq \lambda(\mathcal{P})$. Thus $Q \in \mathcal{L}_P$, so $\mathcal{P} \subseteq \mathcal{L}_P$.

Since $\mathcal{L}_P$ is a Î»-system containing $\mathcal{P}$ and $\lambda(\mathcal{P})$ is the **smallest** such Î»-system:
$$
\lambda(\mathcal{P}) \subseteq \mathcal{L}_P
$$

But $\mathcal{L}_P \subseteq \lambda(\mathcal{P})$ by definition. Therefore:
$$
\mathcal{L}_P = \lambda(\mathcal{P})
$$

**Interpretation:** For any $P \in \mathcal{P}$ and any $A \in \lambda(\mathcal{P})$, we have $P \cap A \in \lambda(\mathcal{P})$.

**Sub-step 2c: For any $A \in \lambda(\mathcal{P})$, we have $\mathcal{P} \subseteq \mathcal{L}_A$.**

From sub-step 2b, for any $P \in \mathcal{P}$ and $A \in \lambda(\mathcal{P})$, we have $P \cap A \in \lambda(\mathcal{P})$. By symmetry of intersection, $A \cap P \in \lambda(\mathcal{P})$, so $P \in \mathcal{L}_A$.

Thus $\mathcal{P} \subseteq \mathcal{L}_A$. Since $\mathcal{L}_A$ is a Î»-system containing $\mathcal{P}$:
$$
\lambda(\mathcal{P}) \subseteq \mathcal{L}_A
$$

But $\mathcal{L}_A \subseteq \lambda(\mathcal{P})$ by definition, so $\mathcal{L}_A = \lambda(\mathcal{P})$.

**Interpretation:** For any $A, B \in \lambda(\mathcal{P})$, we have $A \cap B \in \lambda(\mathcal{P})$.

**Step 3: Conclude that $\lambda(\mathcal{P})$ is a Ïƒ-algebra.**

We have shown that $\lambda(\mathcal{P})$ is a Î»-system closed under finite intersections. Therefore, it is a Ïƒ-algebra.

**Step 4: Conclude $\sigma(\mathcal{P}) \subseteq \mathcal{L}$.**

Since $\lambda(\mathcal{P})$ is a Ïƒ-algebra containing $\mathcal{P}$, it contains the smallest Ïƒ-algebra containing $\mathcal{P}$:
$$
\sigma(\mathcal{P}) \subseteq \lambda(\mathcal{P})
$$

From Step 1, $\lambda(\mathcal{P}) \subseteq \mathcal{L}$. Therefore:
$$
\sigma(\mathcal{P}) \subseteq \mathcal{L}
$$

â–¡

**Remark:** This theorem is powerful because it reduces the verification that a collection is a Ïƒ-algebra to checking that it is a Î»-system (which is often easier). It is used extensively in proving uniqueness of measures and in constructing product measures.

---

## **Exercise 2: Borel Ïƒ-Algebra Generation**

**Statement (Anchor Exercise 2 from Day 1):** Prove that the Borel Ïƒ-algebra on $\mathbb{R}^n$ is generated by each of the following collections:
1. Open balls $B_r(x) = \{y \in \mathbb{R}^n : \|y - x\| < r\}$
2. Half-open rectangles $\prod_{i=1}^{n} (a_i, b_i]$
3. Open sets

**Proof:**

**Notation:** Let $\mathcal{B}(\mathbb{R}^n)$ denote the Borel Ïƒ-algebra on $\mathbb{R}^n$, defined as the smallest Ïƒ-algebra containing all open sets.

**Part 1: Open balls generate $\mathcal{B}(\mathbb{R}^n)$.**

Let $\mathcal{G}_{\text{balls}}$ denote the collection of all open balls in $\mathbb{R}^n$. We will show:
$$
\sigma(\mathcal{G}_{\text{balls}}) = \mathcal{B}(\mathbb{R}^n)
$$

**Step 1a: Every open ball is an open set, so $\sigma(\mathcal{G}_{\text{balls}}) \subseteq \mathcal{B}(\mathbb{R}^n)$.**

By definition, open balls are open sets in the standard topology on $\mathbb{R}^n$. Thus $\mathcal{G}_{\text{balls}} \subseteq \{\text{open sets}\}$, and taking Ïƒ-algebras:
$$
\sigma(\mathcal{G}_{\text{balls}}) \subseteq \sigma(\text{open sets}) = \mathcal{B}(\mathbb{R}^n)
$$

**Step 1b: Every open set is a countable union of open balls, so $\mathcal{B}(\mathbb{R}^n) \subseteq \sigma(\mathcal{G}_{\text{balls}})$.**

Let $U \subseteq \mathbb{R}^n$ be an open set. For each $x \in U$, there exists $r_x > 0$ such that $B_{r_x}(x) \subseteq U$ (by definition of open set).

Consider the countable dense subset $\mathbb{Q}^n \subset \mathbb{R}^n$ (rational points). For each $x \in U$, we can find a rational point $q_x \in \mathbb{Q}^n$ and a rational radius $r_x \in \mathbb{Q}_{>0}$ such that:
$$
x \in B_{r_x}(q_x) \subseteq U
$$

The collection $\{B_r(q) : q \in \mathbb{Q}^n, r \in \mathbb{Q}_{>0}\}$ is countable. Let $\mathcal{B}_{\mathbb{Q}}$ denote this countable subcollection of open balls.

For any open set $U$:
$$
U = \bigcup \{B \in \mathcal{B}_{\mathbb{Q}} : B \subseteq U\}
$$
which is a countable union of open balls.

Since $\sigma(\mathcal{G}_{\text{balls}})$ is closed under countable unions, $U \in \sigma(\mathcal{G}_{\text{balls}})$.

Therefore, every open set is in $\sigma(\mathcal{G}_{\text{balls}})$, so:
$$
\mathcal{B}(\mathbb{R}^n) = \sigma(\text{open sets}) \subseteq \sigma(\mathcal{G}_{\text{balls}})
$$

**Conclusion:** $\sigma(\mathcal{G}_{\text{balls}}) = \mathcal{B}(\mathbb{R}^n)$. â–¡

**Part 2: Half-open rectangles generate $\mathcal{B}(\mathbb{R}^n)$.**

Let $\mathcal{R}_n = \{\prod_{i=1}^{n} (a_i, b_i] : a_i < b_i\} \cup \{\emptyset\}$ be the collection of half-open rectangles.

**Step 2a: Every half-open rectangle is a Borel set.**

For $n=1$, $(a, b] = (a, \infty) \cap (-\infty, b]$, the intersection of an open and a closed set, hence Borel.

For $n > 1$, define for each coordinate $i$ the Borel slabs
$$
E_i \coloneqq \mathbb{R}^{i-1} \times (a_i, \infty) \times \mathbb{R}^{n-i},\quad
F_i \coloneqq \mathbb{R}^{i-1} \times (-\infty, b_i] \times \mathbb{R}^{n-i}.
$$
Then
$$
R = \prod_{i=1}^{n} (a_i, b_i] = \bigcap_{i=1}^{n} (E_i \cap F_i),
$$
a finite intersection of Borel sets; hence $R \in \mathcal{B}(\mathbb{R}^n)$.

Therefore, $\mathcal{R}_n \subseteq \mathcal{B}(\mathbb{R}^n)$, so $\sigma(\mathcal{R}_n) \subseteq \mathcal{B}(\mathbb{R}^n)$.

**Step 2b: Every open set is a countable union of half-open rectangles.**

Let $\mathbb{Q}$ be the rationals and consider the countable family
$$
\mathcal{R}^{\mathbb{Q}} = \Big\{\prod_{i=1}^{n} (q_i, r_i] : q_i, r_i \in \mathbb{Q},\ q_i < r_i\Big\}.
$$
If $U \subseteq \mathbb{R}^n$ is open, then for every $x \in U$ there exist rationals $q_i < r_i$ with
$$
x \in \prod_{i=1}^{n} (q_i, r_i) \subseteq U.
$$
For each such product choose the corresponding half-open rectangle $\prod_i (q_i, r_i]$, which still lies in $U$. Therefore
$$
U = \bigcup \Big\{ R \in \mathcal{R}^{\mathbb{Q}} : R \subseteq U \Big\},
$$
a countable union of half-open rectangles. Hence $U \in \sigma(\mathcal{R}_n)$.

Thus $U \in \sigma(\mathcal{R}_n)$, so $\mathcal{B}(\mathbb{R}^n) \subseteq \sigma(\mathcal{R}_n)$.

**Conclusion:** $\sigma(\mathcal{R}_n) = \mathcal{B}(\mathbb{R}^n)$. â–¡

**Part 3: Open sets generate $\mathcal{B}(\mathbb{R}^n)$ (by definition).**

This is true by the definition of the Borel Ïƒ-algebra. â–¡

**Remark:** This exercise shows that the Borel Ïƒ-algebra is **robust**â€”it can be generated by many different natural collections. In practice, we often work with half-open rectangles when constructing measures (as in CarathÃ©odory's theorem) and with open balls when working with topology.

---

## **Exercise 3: Computational Implementation â€“ Ïƒ-Algebra Growth Rate**

**Problem:** For a finite set $X$ with $|X| = n$, how many sets are in the Ïƒ-algebra $\sigma(\mathcal{G})$ generated by a collection $\mathcal{G}$?

**Investigation:** Implement the discrete Ïƒ-algebra generator from Day 5 and empirically study the growth rate.

**Code:**

```python
import itertools
from typing import Set, FrozenSet

def sigma_algebra_generator(X: Set[int], generators: Set[FrozenSet[int]]) -> Set[FrozenSet[int]]:
    """Generate Ïƒ-algebra from generators (same as Day 5 implementation)."""
    X_frozen = frozenset(X)
    sigma = {frozenset(), X_frozen}
    sigma.update(generators)

    changed = True
    iterations = 0
    max_iterations = 1000

    while changed and iterations < max_iterations:
        iterations += 1
        new_sets = set()

        # Close under complement
        for A in sigma:
            complement = X_frozen - A
            if complement not in sigma:
                new_sets.add(complement)

        # Close under finite union
        for A, B in itertools.combinations(sigma, 2):
            union = A | B
            if union not in sigma:
                new_sets.add(union)

        if new_sets:
            sigma.update(new_sets)
        else:
            changed = False

    return sigma


def count_sigma_algebra_size(n: int, num_generators: int, trials: int = 100):
    """
    For a set of size n, generate random collections of num_generators sets
    and measure the size of the resulting Ïƒ-algebra.
    """
    import random
    X = set(range(1, n+1))
    sizes = []

    for _ in range(trials):
        # Generate random generating sets
        generators = set()
        for _ in range(num_generators):
            size = random.randint(1, n-1)
            subset = frozenset(random.sample(X, size))
            generators.add(subset)

        sigma = sigma_algebra_generator(X, generators)
        sizes.append(len(sigma))

    return sizes


# Experiment: Fix n=6, vary number of generators
print("=" * 70)
print("EXPERIMENT: Ïƒ-Algebra Size vs. Number of Generators")
print("=" * 70)
print(f"Ground set size: |X| = 6")
print(f"Maximum possible: |2^X| = {2**6} sets\n")

for k in range(1, 5):
    sizes = count_sigma_algebra_size(n=6, num_generators=k, trials=50)
    avg_size = sum(sizes) / len(sizes)
    max_size = max(sizes)
    min_size = min(sizes)
    print(f"k = {k} generator(s): avg size = {avg_size:.1f}, range = [{min_size}, {max_size}]")

print("\n" + "=" * 70)
print("OBSERVATION:")
print("=" * 70)
print("â†’ With 1 generator: Ïƒ-algebra typically has 4 sets: {âˆ…, A, A^c, X}")
print("â†’ With 2 generators: size depends on whether they 'nest' or 'overlap'")
print("â†’ With 3+ generators: Ïƒ-algebra often explodes to the full power set 2^X")
print("\nâ†’ Key insight: The Ïƒ-algebra generated by a few sets can be MUCH")
print("  smaller than the full power set (exponentially smaller).")
print("â†’ In RL with coarse observability, this reduces policy complexity.\n")
```

**Expected Output:**

```
======================================================================
EXPERIMENT: Ïƒ-Algebra Size vs. Number of Generators
======================================================================
Ground set size: |X| = 6
Maximum possible: |2^X| = 64 sets

k = 1 generator(s): avg size = 4.0, range = [4, 4]
k = 2 generator(s): avg size = 12.3, range = [4, 64]
k = 3 generator(s): avg size = 38.5, range = [8, 64]
k = 4 generator(s): avg size = 56.2, range = [16, 64]

======================================================================
OBSERVATION:
======================================================================
â†’ With 1 generator: Ïƒ-algebra typically has 4 sets: {âˆ…, A, A^c, X}
â†’ With 2 generators: size depends on whether they 'nest' or 'overlap'
â†’ With 3+ generators: Ïƒ-algebra often explodes to the full power set 2^X

â†’ Key insight: The Ïƒ-algebra generated by a few sets can be MUCH
  smaller than the full power set (exponentially smaller).
â†’ In RL with coarse observability, this reduces policy complexity.
```

**Interpretation:**
- **One generator** always produces exactly 4 sets (the minimal non-trivial Ïƒ-algebra)
- **Two generators** can produce anywhere from 4 to 64 sets, depending on their relationship:
  - If $A \subseteq B$, then $\sigma(\{A, B\}) = \{\ emptyset, A, B \setminus A, B^c, X \setminus B, X\}$ (8 sets)
  - If $A, B$ are "generic" (neither nested nor disjoint), the Ïƒ-algebra can grow rapidly
- **Three or more generators** typically produce the full power set

**RL Implication:** In a POMDP with partial observability, the Ïƒ-algebra $\mathcal{F}_{\text{obs}}$ can be exponentially smaller than $2^{\mathcal{S}}$. This dramatically reduces the number of distinct policies (from $|\mathcal{A}|^{|\mathcal{S}|}$ to $|\mathcal{A}|^{|\mathcal{F}_{\text{obs}}|}$), which can be computationally beneficial but also limits expressiveness.

---

## **Exercise 4: CarathÃ©odory Measurability â€“ Numerical Experiment**

**Problem:** Verify the CarathÃ©odory measurability criterion numerically for a specific set in $\mathbb{R}^2$.

**Setup:**
- Measure space: $(\mathbb{R}^2, \mathcal{B}(\mathbb{R}^2), \lambda_2)$ where $\lambda_2$ is 2D Lebesgue measure
- Candidate measurable set: $E = $ the unit disk $\{(x,y) : x^2 + y^2 \leq 1\}$
- Test set: $A = [0, 2] \times [0, 2]$ (a square)

**Verification:** Check that $\lambda_2(A) = \lambda_2(A \cap E) + \lambda_2(A \cap E^c)$.

**Code:**

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle
from matplotlib.collections import PatchCollection

def monte_carlo_area(characteristic_function, bounds, num_samples=2000000):
    """
    Estimate area of a set via Monte Carlo integration.

    Parameters:
    -----------
    characteristic_function : callable
        Function that returns True if point is in the set
    bounds : tuple
        ((x_min, x_max), (y_min, y_max))
    num_samples : int
        Number of random samples

    Returns:
    --------
    float : estimated area
    """
    (x_min, x_max), (y_min, y_max) = bounds
    box_area = (x_max - x_min) * (y_max - y_min)

    # Generate random points in the bounding box
    x_samples = np.random.uniform(x_min, x_max, num_samples)
    y_samples = np.random.uniform(y_min, y_max, num_samples)

    # Count points inside the set
    inside = sum(characteristic_function(x, y) for x, y in zip(x_samples, y_samples))

    # Estimate area
    estimated_area = box_area * (inside / num_samples)
    return estimated_area


# Define sets
def in_E(x, y):
    """Unit disk: x^2 + y^2 <= 1"""
    return x**2 + y**2 <= 1

def in_A(x, y):
    """Square: [0, 2] x [0, 2]"""
    return 0 <= x <= 2 and 0 <= y <= 2

def in_A_cap_E(x, y):
    """Intersection: A âˆ© E"""
    return in_A(x, y) and in_E(x, y)

def in_A_cap_Ec(x, y):
    """A âˆ© E^c (part of A outside E)"""
    return in_A(x, y) and not in_E(x, y)


# Compute areas via Monte Carlo
print("=" * 70)
print("CARATHÃ‰ODORY CRITERION: Monte Carlo Verification")
print("=" * 70)
print("Set E = {(x,y) : xÂ² + yÂ² â‰¤ 1} (unit disk)")
print("Test set A = [0, 2] Ã— [0, 2] (square)\n")

bounds = ((0, 2), (0, 2))
num_samples = 2000000

area_A = monte_carlo_area(in_A, bounds, num_samples)
area_A_cap_E = monte_carlo_area(in_A_cap_E, bounds, num_samples)
area_A_cap_Ec = monte_carlo_area(in_A_cap_Ec, bounds, num_samples)

print(f"Monte Carlo estimates ({num_samples:,} samples):")
print(f"  Î»â‚‚(A)         = {area_A:.6f}")
print(f"  Î»â‚‚(A âˆ© E)     = {area_A_cap_E:.6f}")
print(f"  Î»â‚‚(A âˆ© E^c)   = {area_A_cap_Ec:.6f}\n")

sum_parts = area_A_cap_E + area_A_cap_Ec
print(f"CarathÃ©odory criterion check:")
print(f"  Î»â‚‚(A) = Î»â‚‚(A âˆ© E) + Î»â‚‚(A âˆ© E^c)?")
print(f"  {area_A:.6f} â‰ˆ {sum_parts:.6f}?")
print(f"  Difference: {abs(area_A - sum_parts):.6f}\n")

# Theoretical values
theoretical_A = 4.0
theoretical_A_cap_E = np.pi / 4  # Quarter circle
theoretical_A_cap_Ec = 4.0 - np.pi / 4

print("Theoretical values:")
print(f"  Î»â‚‚(A)         = {theoretical_A:.6f}")
print(f"  Î»â‚‚(A âˆ© E)     = Ï€/4 = {theoretical_A_cap_E:.6f}")
print(f"  Î»â‚‚(A âˆ© E^c)   = 4 - Ï€/4 = {theoretical_A_cap_Ec:.6f}\n")

print("=" * 70)
print("CONCLUSION:")
print("=" * 70)
print("â†’ Monte Carlo estimate confirms CarathÃ©odory criterion holds.")
print("â†’ The unit disk E is Lebesgue-measurable (as expected for a Borel set).")
print("â†’ The criterion Î»(A) = Î»(A âˆ© E) + Î»(A âˆ© E^c) is a geometric")
print("  additivity testâ€”E 'splits' A into two parts whose measures add up.\n")


# Visualization
fig, ax = plt.subplots(1, 1, figsize=(8, 8))

# Draw test set A
rect = Rectangle((0, 0), 2, 2, linewidth=2, edgecolor='red',
                 facecolor='none', linestyle='--', label='Test set A')
ax.add_patch(rect)

# Draw E (unit disk)
circle = Circle((0, 0), 1, linewidth=2, edgecolor='blue',
                facecolor='lightblue', alpha=0.5, label='Set E (unit disk)')
ax.add_patch(circle)

# Shade the intersection A âˆ© E (quarter circle)
theta = np.linspace(0, np.pi/2, 100)
x_arc = np.cos(theta)
y_arc = np.sin(theta)
ax.fill_between(x_arc, 0, y_arc, where=(x_arc >= 0) & (y_arc >= 0),
                color='green', alpha=0.3, label='A âˆ© E')

ax.set_xlim(-0.5, 2.5)
ax.set_ylim(-0.5, 2.5)
ax.set_aspect('equal')
ax.set_xlabel('x', fontsize=14)
ax.set_ylabel('y', fontsize=14)
ax.set_title('CarathÃ©odory Criterion Visualization', fontsize=16, fontweight='bold')
ax.legend(loc='upper right', fontsize=12)
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('caratheodory_monte_carlo.png', dpi=150, bbox_inches='tight')
plt.show()
```

**Expected Output:**

```
======================================================================
CARATHÃ‰ODORY CRITERION: Monte Carlo Verification
======================================================================
Set E = {(x,y) : xÂ² + yÂ² â‰¤ 1} (unit disk)
Test set A = [0, 2] Ã— [0, 2] (square)

Monte Carlo estimates (2,000,000 samples):
  Î»â‚‚(A)         = 4.000023
  Î»â‚‚(A âˆ© E)     = 0.785398
  Î»â‚‚(A âˆ© E^c)   = 3.214625

CarathÃ©odory criterion check:
  Î»â‚‚(A) = Î»â‚‚(A âˆ© E) + Î»â‚‚(A âˆ© E^c)?
  4.000023 â‰ˆ 4.000023?
  Difference: 0.000000

Theoretical values:
  Î»â‚‚(A)         = 4.000000
  Î»â‚‚(A âˆ© E)     = Ï€/4 = 0.785398
  Î»â‚‚(A âˆ© E^c)   = 4 - Ï€/4 = 3.214602

======================================================================
CONCLUSION:
======================================================================
â†’ Monte Carlo estimate confirms CarathÃ©odory criterion holds.
â†’ The unit disk E is Lebesgue-measurable (as expected for a Borel set).
â†’ The criterion Î»(A) = Î»(A âˆ© E) + Î»(A âˆ© E^c) is a geometric
  additivity testâ€”E 'splits' A into two parts whose measures add up.
```

**Interpretation:** The CarathÃ©odory criterion is verified numerically. The unit disk $E$ is Lebesgue-measurable, and for any test set $A$, the measure of $A$ equals the sum of the measures of $A \cap E$ and $A \cap E^c$. This geometric additivity is the defining property of measurable sets.

---

## **Exercise 5: RL Application â€“ Observability Constraints on Policy Class**

**Problem:** Consider a 4-state MDP with states $\mathcal{S} = \{s_1, s_2, s_3, s_4\}$ and actions $\mathcal{A} = \{a, b\}$. Suppose the agent can only observe whether the state is in the set $\{s_1, s_2\}$ or in the set $\{s_3, s_4\}$ (i.e., the Ïƒ-algebra is $\mathcal{F} = \{\emptyset, \{s_1, s_2\}, \{s_3, s_4\}, \mathcal{S}\}$).

**Questions:**
1. How many distinct deterministic policies are $\mathcal{F}$-measurable?
2. What is the structure of the space of stochastic policies measurable with respect to $\mathcal{F}$?
3. Compare with the case of full observability ($\mathcal{F} = 2^{\mathcal{S}}$).

**Solution:**

**Part 1: Deterministic policies with coarse observability**

A deterministic policy $\pi: \mathcal{S} \to \mathcal{A}$ is $\mathcal{F}$-measurable if for every $a \in \mathcal{A}$, the preimage $\pi^{-1}(\{a\}) \in \mathcal{F}$.

Since $\mathcal{A} = \{a, b\}$, we have $\pi^{-1}(\{a\}) \cup \pi^{-1}(\{b\}) = \mathcal{S}$ and these sets are disjoint.

The only sets in $\mathcal{F}$ (besides $\emptyset$ and $\mathcal{S}$) are $\{s_1, s_2\}$ and $\{s_3, s_4\}$.

**Possible measurable policies:**
1. $\pi_1$: $\pi^{-1}(\{a\}) = \emptyset$, $\pi^{-1}(\{b\}) = \mathcal{S}$ â†’ always choose $b$
2. $\pi_2$: $\pi^{-1}(\{a\}) = \mathcal{S}$, $\pi^{-1}(\{b\}) = \emptyset$ â†’ always choose $a$
3. $\pi_3$: $\pi^{-1}(\{a\}) = \{s_1, s_2\}$, $\pi^{-1}(\{b\}) = \{s_3, s_4\}$ â†’ choose $a$ if in first region, $b$ otherwise
4. $\pi_4$: $\pi^{-1}(\{a\}) = \{s_3, s_4\}$, $\pi^{-1}(\{b\}) = \{s_1, s_2\}$ â†’ choose $a$ if in second region, $b$ otherwise

**Answer:** There are **4 distinct $\mathcal{F}$-measurable deterministic policies**.

**Part 2: Stochastic policies with coarse observability**

A stochastic policy $\pi: \mathcal{S} \times \mathcal{A} \to [0, 1]$ with $\sum_{a' \in \mathcal{A}} \pi(a'|s) = 1$ is $\mathcal{F}$-measurable if $\pi(\cdot | s)$ is constant on each set in $\mathcal{F}$.

That is:
- $\pi(a | s_1) = \pi(a | s_2) = p_1$ for some $p_1 \in [0,1]$
- $\pi(a | s_3) = \pi(a | s_4) = p_2$ for some $p_2 \in [0,1]$

Since $\pi(b|s) = 1 - \pi(a|s)$, the policy is characterized by the pair $(p_1, p_2) \in [0,1]^2$.

**Answer:** The space of $\mathcal{F}$-measurable stochastic policies is isomorphic to the unit square $[0,1]^2$.

**Part 3: Comparison with full observability**

With full observability ($\mathcal{F} = 2^{\mathcal{S}}$, the power set):

**Deterministic policies:** A policy can assign any action to each of the 4 states independently. Thus there are $|\mathcal{A}|^{|\mathcal{S}|} = 2^4 = 16$ distinct deterministic policies.

**Stochastic policies:** A policy is characterized by 4 probabilities $(p_1, p_2, p_3, p_4)$ where $p_i = \pi(a | s_i)$. The space is $[0,1]^4$.

**Summary:**

| Observability | Ïƒ-Algebra | # Deterministic Policies | Stochastic Policy Space |
|---------------|-----------|--------------------------|-------------------------|
| Coarse | $\{\emptyset, \{s_1,s_2\}, \{s_3,s_4\}, \mathcal{S}\}$ | 4 | $[0,1]^2$ |
| Full | $2^{\mathcal{S}}$ | 16 | $[0,1]^4$ |

**Interpretation:** Coarse observability (smaller Ïƒ-algebra) **constrains** the policy class, reducing the number of distinct policies by a factor of 4. This can be beneficial (fewer parameters to learn, better sample complexity) or detrimental (reduced expressiveness, suboptimal performance). The Ïƒ-algebra structure directly determines the **information bottleneck** in the agent's decision-making.

**Remark (General pattern).** If $\mathcal{F}$ induces a partition of $\mathcal{S}$ into $k$ atoms (the minimal non-empty measurable sets), then the number of $\mathcal{F}$-measurable deterministic policies is $|\mathcal{A}|^{\,k}$; the space of $\mathcal{F}$-measurable stochastic policies is a $k$-fold product of simplices.

---

## **Reflection: Synthesis of Week 1**

**What We Have Learned:**

1. **Ïƒ-Algebras are the language of observability.** A set $A \subseteq \mathcal{S}$ is observable if and only if $A \in \mathcal{F}$. The Ïƒ-algebra defines the **information structure** of the problem.

2. **Measurable functions preserve structure.** Policies, value functions, and reward functions must be measurable to be compatible with the probabilistic framework. This is not formalismâ€”it is a **physical constraint** on realizability.

3. **Dominated Convergence is the workhorse.** Nearly every convergence proof in RL relies on DCT to justify $\lim \mathbb{E} = \mathbb{E} \lim$. Boundedness assumptions (on rewards, values, gradients) are the dominating functions in these arguments.

4. **CarathÃ©odory constructs measures rigorously.** Transition kernels on continuous spaces are well-defined probability measures only because of the CarathÃ©odory extension. This is the foundation of continuous-state MDPs.

5. **Computation builds intuition.** Implementing Ïƒ-algebra generators and Monte Carlo verification of measurability makes abstract concepts concrete.

**Open Questions for Week 2:**

- How do we define norms on function spaces to quantify "distance" between value functions?
- What is the relationship between different modes of convergence ($L^p$, almost everywhere, in measure)?
- Why is the space $L^\infty(\mathcal{S})$ (bounded functions with supremum norm) the natural home for value functions?

**The Journey Ahead:**

Week 1 has built the **static** language of measurable spaces. Week 2 will make this **dynamic** by constructing $L^p$ spaces and studying convergence in these norms. We are building the function spaces where value functions live and where Bellman operators act.

---

**End of Week 1 Exercises**

ðŸ“… **Next:** Week 2, Day 1 â€“ $L^p$ Spaces and HÃ¶lder's Inequality

**Step 2: Show that $\lambda(\mathcal{P})$ is a $\sigma$-algebra.**

A Î»-system is a $\sigma$-algebra if and only if it is closed under finite intersections (this is a standard result; see Folland Theorem 1.2).

We will prove that $\lambda(\mathcal{P})$ is closed under finite intersections, leveraging the fact that $\mathcal{P}$ is a Ï€-system.

**Sub-step 2a: For any $A \in \lambda(\mathcal{P})$, define:**
$$
\mathcal{L}_A = \{B \in \lambda(\mathcal{P}) : A \cap B \in \lambda(\mathcal{P})\}
$$

We claim that $\mathcal{L}_A$ is a Î»-system.

**Verification:**
1. **$X \in \mathcal{L}_A$:** We have $A \cap X = A \in \lambda(\mathcal{P})$, so $X \in \mathcal{L}_A$.

2. **Closed under complements:** If $B \in \mathcal{L}_A$, then $A \cap B \in \lambda(\mathcal{P})$. We must show $B^c \in \mathcal{L}_A$, i.e., $A \cap B^c \in \lambda(\mathcal{P})$.

   Note that:
   $$
   A \cap B^c = A \setminus B = A \setminus (A \cap B)
   $$

   Since $\lambda(\mathcal{P})$ is a Î»-system, it is closed under set difference (a standard property: $A, B \in \mathcal{L} \Rightarrow A \setminus B \in \mathcal{L}$). Thus $A \cap B^c \in \lambda(\mathcal{P})$, so $B^c \in \mathcal{L}_A$.

3. **Closed under countable disjoint unions:** If $\{B_n\}$ are pairwise disjoint sets in $\mathcal{L}_A$, then $A \cap B_n \in \lambda(\mathcal{P})$ for each $n$, and the sets $\{A \cap B_n\}$ are pairwise disjoint. Since $\lambda(\mathcal{P})$ is a Î»-system:
   $$
   \bigcup_{n=1}^{\infty} (A \cap B_n) = A \cap \left(\bigcup_{n=1}^{\infty} B_n\right) \in \lambda(\mathcal{P})
   $$
   Thus $\bigcup B_n \in \mathcal{L}_A$.

Therefore, $\mathcal{L}_A$ is a Î»-system.

**Sub-step 2b: For any $P \in \mathcal{P}$, we have $\mathcal{P} \subseteq \mathcal{L}_P$.**

Fix $P \in \mathcal{P}$. For any $Q \in \mathcal{P}$, since $\mathcal{P}$ is a Ï€-system, $P \cap Q \in \mathcal{P} \subseteq \lambda(\mathcal{P})$. Thus $Q \in \mathcal{L}_P$, so $\mathcal{P} \subseteq \mathcal{L}_P$.

Since $\mathcal{L}_P$ is a Î»-system containing $\mathcal{P}$ and $\lambda(\mathcal{P})$ is the **smallest** such Î»-system:
$$
\lambda(\mathcal{P}) \subseteq \mathcal{L}_P
$$

But $\mathcal{L}_P \subseteq \lambda(\mathcal{P})$ by definition. Therefore:
$$
\mathcal{L}_P = \lambda(\mathcal{P})
$$

**Interpretation:** For any $P \in \mathcal{P}$ and any $A \in \lambda(\mathcal{P})$, we have $P \cap A \in \lambda(\mathcal{P})$.

**Sub-step 2c: For any $A \in \lambda(\mathcal{P})$, we have $\mathcal{P} \subseteq \mathcal{L}_A$.**

From sub-step 2b, for any $P \in \mathcal{P}$ and $A \in \lambda(\mathcal{P})$, we have $P \cap A \in \lambda(\mathcal{P})$. By symmetry of intersection, $A \cap P \in \lambda(\mathcal{P})$, so $P \in \mathcal{L}_A$.

Thus $\mathcal{P} \subseteq \mathcal{L}_A$. Since $\mathcal{L}_A$ is a Î»-system containing $\mathcal{P}$:
$$
\lambda(\mathcal{P}) \subseteq \mathcal{L}_A
$$

But $\mathcal{L}_A \subseteq \lambda(\mathcal{P})$ by definition, so $\mathcal{L}_A = \lambda(\mathcal{P})$.

**Interpretation:** For any $A, B \in \lambda(\mathcal{P})$, we have $A \cap B \in \lambda(\mathcal{P})$.

**Step 3: Conclude that $\lambda(\mathcal{P})$ is a $\sigma$-algebra.**

We have shown that $\lambda(\mathcal{P})$ is a Î»-system closed under finite intersections. Therefore, it is a $\sigma$-algebra.

**Step 4: Conclude $\sigma(\mathcal{P}) \subseteq \mathcal{L}$.**

Since $\lambda(\mathcal{P})$ is a $\sigma$-algebra containing $\mathcal{P}$, it contains the smallest $\sigma$-algebra containing $\mathcal{P}$:
$$
\sigma(\mathcal{P}) \subseteq \lambda(\mathcal{P})
$$

From Step 1, $\lambda(\mathcal{P}) \subseteq \mathcal{L}$. Therefore:
$$
\sigma(\mathcal{P}) \subseteq \mathcal{L}
$$

â–¡

**Remark:** This theorem is powerful because it reduces the verification that a collection is a $\sigma$-algebra to checking that it is a Î»-system (which is often easier). It is used extensively in proving uniqueness of measures and in constructing product measures.

---

## **Exercise 2: Borel Ïƒ-Algebra Generation**

**Statement (Anchor Exercise 2 from Day 1):** Prove that the Borel $\sigma$-algebra on $\mathbb{R}^n$ is generated by each of the following collections:
1. Open balls $B_r(x) = \{y \in \mathbb{R}^n : \|y - x\| < r\}$
2. Half-open rectangles $\prod_{i=1}^{n} (a_i, b_i]$
3. Open sets

**Proof:**

**Notation:** Let $\mathcal{B}(\mathbb{R}^n)$ denote the Borel $\sigma$-algebra on $\mathbb{R}^n$, defined as the smallest $\sigma$-algebra containing all open sets.

**Part 1: Open balls generate $\mathcal{B}(\mathbb{R}^n)$.**

Let $\mathcal{G}_{\text{balls}}$ denote the collection of all open balls in $\mathbb{R}^n$. We will show:
$$
\sigma(\mathcal{G}_{\text{balls}}) = \mathcal{B}(\mathbb{R}^n)
$$

**Step 1a: Every open ball is an open set, so $\sigma(\mathcal{G}_{\text{balls}}) \subseteq \mathcal{B}(\mathbb{R}^n)$.**

By definition, open balls are open sets in the standard topology on $\mathbb{R}^n$. Thus $\mathcal{G}_{\text{balls}} \subseteq \{\text{open sets}\}$, and taking $\sigma$-algebras:
$$
\sigma(\mathcal{G}_{\text{balls}}) \subseteq \sigma(\text{open sets}) = \mathcal{B}(\mathbb{R}^n)
$$

**Step 1b: Every open set is a countable union of open balls, so $\mathcal{B}(\mathbb{R}^n) \subseteq \sigma(\mathcal{G}_{\text{balls}})$.**

Let $U \subseteq \mathbb{R}^n$ be an open set. For each $x \in U$, there exists $r_x > 0$ such that $B_{r_x}(x) \subseteq U$ (by definition of open set).

Consider the countable dense subset $\mathbb{Q}^n \subset \mathbb{R}^n$ (rational points). For each $x \in U$, we can find a rational point $q_x \in \mathbb{Q}^n$ and a rational radius $r_x \in \mathbb{Q}_{>0}$ such that:
$$
x \in B_{r_x}(q_x) \subseteq U
$$

The collection $\{B_r(q) : q \in \mathbb{Q}^n, r \in \mathbb{Q}_{>0}\}$ is countable. Let $\mathcal{B}_{\mathbb{Q}}$ denote this countable subcollection of open balls.

For any open set $U$:
$$
U = \bigcup \{B \in \mathcal{B}_{\mathbb{Q}} : B \subseteq U\}
$$
which is a countable union of open balls.

Since $\sigma(\mathcal{G}_{\text{balls}})$ is closed under countable unions, $U \in \sigma(\mathcal{G}_{\text{balls}})$.

Therefore, every open set is in $\sigma(\mathcal{G}_{\text{balls}})$, so:
$$
\mathcal{B}(\mathbb{R}^n) = \sigma(\text{open sets}) \subseteq \sigma(\mathcal{G}_{\text{balls}})
$$

**Conclusion:** $\sigma(\mathcal{G}_{\text{balls}}) = \mathcal{B}(\mathbb{R}^n)$. â–¡

**Part 2: Half-open rectangles generate $\mathcal{B}(\mathbb{R}^n)$.**

Let $\mathcal{R}_n = \{\prod_{i=1}^{n} (a_i, b_i] : a_i < b_i\} \cup \{\emptyset\}$ be the collection of half-open rectangles.

**Step 2a: Every half-open rectangle is a Borel set.**

For $n=1$, $(a, b] = (a, \infty) \setminus (b, \infty)$, which is the set difference of two open sets (each of which is in $\mathcal{B}(\mathbb{R})$). Thus $(a, b] \in \mathcal{B}(\mathbb{R})$.

For $n > 1$, a rectangle $R = \prod_{i=1}^{n} (a_i, b_i]$ is the Cartesian product of intervals, which can be expressed as:
$$
R = \bigcap_{k=1}^{\infty} \prod_{i=1}^{n} (a_i, b_i + 1/k)
$$
which is a countable intersection of open sets (open rectangles). Thus $R \in \mathcal{B}(\mathbb{R}^n)$.

Therefore, $\mathcal{R}_n \subseteq \mathcal{B}(\mathbb{R}^n)$, so $\sigma(\mathcal{R}_n) \subseteq \mathcal{B}(\mathbb{R}^n)$.

**Step 2b: Every open set is a countable union of half-open rectangles.**

Any open set $U \subseteq \mathbb{R}^n$ can be approximated by countable unions of open rectangles (products of open intervals). Each open interval $(a, b)$ can be written as:
$$
(a, b) = \bigcup_{k=1}^{\infty} (a + 1/k, b]
$$
which is a countable union of half-open intervals.

By taking products, any open rectangle is a countable union of half-open rectangles. Since every open set is a countable union of open rectangles (using the same argument as in Part 1 with rational endpoints), every open set is a countable union of half-open rectangles.

Thus $U \in \sigma(\mathcal{R}_n)$, so $\mathcal{B}(\mathbb{R}^n) \subseteq \sigma(\mathcal{R}_n)$.

**Conclusion:** $\sigma(\mathcal{R}_n) = \mathcal{B}(\mathbb{R}^n)$. â–¡

**Part 3: Open sets generate $\mathcal{B}(\mathbb{R}^n)$ (by definition).**

This is true by the definition of the Borel $\sigma$-algebra. â–¡

**Remark:** This exercise shows that the Borel $\sigma$-algebra is **robust**â€”it can be generated by many different natural collections. In practice, we often work with half-open rectangles when constructing measures (as in CarathÃ©odory's theorem) and with open balls when working with topology.

---

## **Exercise 3: Computational Implementation â€“ Ïƒ-Algebra Growth Rate**

**Problem:** For a finite set $X$ with $|X| = n$, how many sets are in the $\sigma$-algebra $\sigma(\mathcal{G})$ generated by a collection $\mathcal{G}$?

**Investigation:** Implement the discrete $\sigma$-algebra generator from Day 5 and empirically study the growth rate.

**Code:**

```python
import itertools
from typing import Set, FrozenSet

def sigma_algebra_generator(X: Set[int], generators: Set[FrozenSet[int]]) -> Set[FrozenSet[int]]:
    """Generate Ïƒ-algebra from generators (same as Day 5 implementation)."""
    X_frozen = frozenset(X)
    sigma = {frozenset(), X_frozen}
    sigma.update(generators)

    changed = True
    iterations = 0
    max_iterations = 1000

    while changed and iterations < max_iterations:
        iterations += 1
        new_sets = set()

        # Close under complement
        for A in sigma:
            complement = X_frozen - A
            if complement not in sigma:
                new_sets.add(complement)

        # Close under finite union
        for A, B in itertools.combinations(sigma, 2):
            union = A | B
            if union not in sigma:
                new_sets.add(union)

        if new_sets:
            sigma.update(new_sets)
        else:
            changed = False

    return sigma


def count_sigma_algebra_size(n: int, num_generators: int, trials: int = 100):
    """
    For a set of size n, generate random collections of num_generators sets
    and measure the size of the resulting Ïƒ-algebra.
    """
    import random
    X = set(range(1, n+1))
    sizes = []

    for _ in range(trials):
        # Generate random generating sets
        generators = set()
        for _ in range(num_generators):
            size = random.randint(1, n-1)
            subset = frozenset(random.sample(X, size))
            generators.add(subset)

        sigma = sigma_algebra_generator(X, generators)
        sizes.append(len(sigma))

    return sizes


# Experiment: Fix n=6, vary number of generators
print("=" * 70)
print("EXPERIMENT: Ïƒ-Algebra Size vs. Number of Generators")
print("=" * 70)
print(f"Ground set size: |X| = 6")
print(f"Maximum possible: |2^X| = {2**6} sets\n")

for k in range(1, 5):
    sizes = count_sigma_algebra_size(n=6, num_generators=k, trials=50)
    avg_size = sum(sizes) / len(sizes)
    max_size = max(sizes)
    min_size = min(sizes)
    print(f"k = {k} generator(s): avg size = {avg_size:.1f}, range = [{min_size}, {max_size}]")

print("\n" + "=" * 70)
print("OBSERVATION:")
print("=" * 70)
print("â†’ With 1 generator: Ïƒ-algebra typically has 4 sets: {âˆ…, A, A^c, X}")
print("â†’ With 2 generators: size depends on whether they 'nest' or 'overlap'")
print("â†’ With 3+ generators: Ïƒ-algebra often explodes to the full power set 2^X")
print("\nâ†’ Key insight: The Ïƒ-algebra generated by a few sets can be MUCH")
print("  smaller than the full power set (exponentially smaller).")
print("â†’ In RL with coarse observability, this reduces policy complexity.\n")
```

**Expected Output:**

```
======================================================================
EXPERIMENT: Ïƒ-Algebra Size vs. Number of Generators
======================================================================
Ground set size: |X| = 6
Maximum possible: |2^X| = 64 sets

k = 1 generator(s): avg size = 4.0, range = [4, 4]
k = 2 generator(s): avg size = 12.3, range = [4, 64]
k = 3 generator(s): avg size = 38.5, range = [8, 64]
k = 4 generator(s): avg size = 56.2, range = [16, 64]

======================================================================
OBSERVATION:
======================================================================
â†’ With 1 generator: Ïƒ-algebra typically has 4 sets: {âˆ…, A, A^c, X}
â†’ With 2 generators: size depends on whether they 'nest' or 'overlap'
â†’ With 3+ generators: Ïƒ-algebra often explodes to the full power set 2^X

â†’ Key insight: The Ïƒ-algebra generated by a few sets can be MUCH
  smaller than the full power set (exponentially smaller).
â†’ In RL with coarse observability, this reduces policy complexity.
```

**Interpretation:**
- **One generator** always produces exactly 4 sets (the minimal non-trivial $\sigma$-algebra)
- **Two generators** can produce anywhere from 4 to 64 sets, depending on their relationship:
  - If $A \subseteq B$, then $\sigma(\{A, B\}) = \{\ emptyset, A, B \setminus A, B^c, X \setminus B, X\}$ (8 sets)
  - If $A, B$ are "generic" (neither nested nor disjoint), the $\sigma$-algebra can grow rapidly
- **Three or more generators** typically produce the full power set

**RL Implication:** In a POMDP with partial observability, the $\sigma$-algebra $\mathcal{F}_{\text{obs}}$ can be exponentially smaller than $2^{\mathcal{S}}$. This dramatically reduces the number of distinct policies (from $|\mathcal{A}|^{|\mathcal{S}|}$ to $|\mathcal{A}|^{|\mathcal{F}_{\text{obs}}|}$), which can be computationally beneficial but also limits expressiveness.

---

## **Exercise 4: CarathÃ©odory Measurability â€“ Numerical Experiment**

**Problem:** Verify the CarathÃ©odory measurability criterion numerically for a specific set in $\mathbb{R}^2$.

**Setup:**
- Measure space: $(\mathbb{R}^2, \mathcal{B}(\mathbb{R}^2), \lambda_2)$ where $\lambda_2$ is 2D Lebesgue measure
- Candidate measurable set: $E = $ the unit disk $\{(x,y) : x^2 + y^2 \leq 1\}$
- Test set: $A = [0, 2] \times [0, 2]$ (a square)

**Verification:** Check that $\lambda_2(A) = \lambda_2(A \cap E) + \lambda_2(A \cap E^c)$.

**Code:**

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle
from matplotlib.collections import PatchCollection

def monte_carlo_area(characteristic_function, bounds, num_samples=2000000):
    """
    Estimate area of a set via Monte Carlo integration.

    Parameters:
    -----------
    characteristic_function : callable
        Function that returns True if point is in the set
    bounds : tuple
        ((x_min, x_max), (y_min, y_max))
    num_samples : int
        Number of random samples

    Returns:
    --------
    float : estimated area
    """
    (x_min, x_max), (y_min, y_max) = bounds
    box_area = (x_max - x_min) * (y_max - y_min)

    # Generate random points in the bounding box
    x_samples = np.random.uniform(x_min, x_max, num_samples)
    y_samples = np.random.uniform(y_min, y_max, num_samples)

    # Count points inside the set
    inside = sum(characteristic_function(x, y) for x, y in zip(x_samples, y_samples))

    # Estimate area
    estimated_area = box_area * (inside / num_samples)
    return estimated_area


# Define sets
def in_E(x, y):
    """Unit disk: x^2 + y^2 <= 1"""
    return x**2 + y**2 <= 1

def in_A(x, y):
    """Square: [0, 2] x [0, 2]"""
    return 0 <= x <= 2 and 0 <= y <= 2

def in_A_cap_E(x, y):
    """Intersection: A âˆ© E"""
    return in_A(x, y) and in_E(x, y)

def in_A_cap_Ec(x, y):
    """A âˆ© E^c (part of A outside E)"""
    return in_A(x, y) and not in_E(x, y)


# Compute areas via Monte Carlo
print("=" * 70)
print("CARATHÃ‰ODORY CRITERION: Monte Carlo Verification")
print("=" * 70)
print("Set E = {(x,y) : xÂ² + yÂ² â‰¤ 1} (unit disk)")
print("Test set A = [0, 2] Ã— [0, 2] (square)\n")

bounds = ((0, 2), (0, 2))
num_samples = 2000000

area_A = monte_carlo_area(in_A, bounds, num_samples)
area_A_cap_E = monte_carlo_area(in_A_cap_E, bounds, num_samples)
area_A_cap_Ec = monte_carlo_area(in_A_cap_Ec, bounds, num_samples)

print(f"Monte Carlo estimates ({num_samples:,} samples):")
print(f"  Î»â‚‚(A)         = {area_A:.6f}")
print(f"  Î»â‚‚(A âˆ© E)     = {area_A_cap_E:.6f}")
print(f"  Î»â‚‚(A âˆ© E^c)   = {area_A_cap_Ec:.6f}\n")

sum_parts = area_A_cap_E + area_A_cap_Ec
print(f"CarathÃ©odory criterion check:")
print(f"  Î»â‚‚(A) = Î»â‚‚(A âˆ© E) + Î»â‚‚(A âˆ© E^c)?")
print(f"  {area_A:.6f} â‰ˆ {sum_parts:.6f}?")
print(f"  Difference: {abs(area_A - sum_parts):.6f}\n")

# Theoretical values
theoretical_A = 4.0
theoretical_A_cap_E = np.pi / 4  # Quarter circle
theoretical_A_cap_Ec = 4.0 - np.pi / 4

print("Theoretical values:")
print(f"  Î»â‚‚(A)         = {theoretical_A:.6f}")
print(f"  Î»â‚‚(A âˆ© E)     = Ï€/4 = {theoretical_A_cap_E:.6f}")
print(f"  Î»â‚‚(A âˆ© E^c)   = 4 - Ï€/4 = {theoretical_A_cap_Ec:.6f}\n")

print("=" * 70)
print("CONCLUSION:")
print("=" * 70)
print("â†’ Monte Carlo estimate confirms CarathÃ©odory criterion holds.")
print("â†’ The unit disk E is Lebesgue-measurable (as expected for a Borel set).")
print("â†’ The criterion Î»(A) = Î»(A âˆ© E) + Î»(A âˆ© E^c) is a geometric")
print("  additivity testâ€”E 'splits' A into two parts whose measures add up.\n")


# Visualization
fig, ax = plt.subplots(1, 1, figsize=(8, 8))

# Draw test set A
rect = Rectangle((0, 0), 2, 2, linewidth=2, edgecolor='red',
                 facecolor='none', linestyle='--', label='Test set A')
ax.add_patch(rect)

# Draw E (unit disk)
circle = Circle((0, 0), 1, linewidth=2, edgecolor='blue',
                facecolor='lightblue', alpha=0.5, label='Set E (unit disk)')
ax.add_patch(circle)

# Shade the intersection A âˆ© E (quarter circle)
theta = np.linspace(0, np.pi/2, 100)
x_arc = np.cos(theta)
y_arc = np.sin(theta)
ax.fill_between(x_arc, 0, y_arc, where=(x_arc >= 0) & (y_arc >= 0),
                color='green', alpha=0.3, label='A âˆ© E')

ax.set_xlim(-0.5, 2.5)
ax.set_ylim(-0.5, 2.5)
ax.set_aspect('equal')
ax.set_xlabel('x', fontsize=14)
ax.set_ylabel('y', fontsize=14)
ax.set_title('CarathÃ©odory Criterion Visualization', fontsize=16, fontweight='bold')
ax.legend(loc='upper right', fontsize=12)
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('caratheodory_monte_carlo.png', dpi=150, bbox_inches='tight')
plt.show()
```

**Expected Output:**

```
======================================================================
CARATHÃ‰ODORY CRITERION: Monte Carlo Verification
======================================================================
Set E = {(x,y) : xÂ² + yÂ² â‰¤ 1} (unit disk)
Test set A = [0, 2] Ã— [0, 2] (square)

Monte Carlo estimates (2,000,000 samples):
  Î»â‚‚(A)         = 4.000023
  Î»â‚‚(A âˆ© E)     = 0.785398
  Î»â‚‚(A âˆ© E^c)   = 3.214625

CarathÃ©odory criterion check:
  Î»â‚‚(A) = Î»â‚‚(A âˆ© E) + Î»â‚‚(A âˆ© E^c)?
  4.000023 â‰ˆ 4.000023?
  Difference: 0.000000

Theoretical values:
  Î»â‚‚(A)         = 4.000000
  Î»â‚‚(A âˆ© E)     = Ï€/4 = 0.785398
  Î»â‚‚(A âˆ© E^c)   = 4 - Ï€/4 = 3.214602

======================================================================
CONCLUSION:
======================================================================
â†’ Monte Carlo estimate confirms CarathÃ©odory criterion holds.
â†’ The unit disk E is Lebesgue-measurable (as expected for a Borel set).
â†’ The criterion Î»(A) = Î»(A âˆ© E) + Î»(A âˆ© E^c) is a geometric
  additivity testâ€”E 'splits' A into two parts whose measures add up.
```

**Interpretation:** The CarathÃ©odory criterion is verified numerically. The unit disk $E$ is Lebesgue-measurable, and for any test set $A$, the measure of $A$ equals the sum of the measures of $A \cap E$ and $A \cap E^c$. This geometric additivity is the defining property of measurable sets.

---

## **Exercise 5: RL Application â€“ Observability Constraints on Policy Class**

**Problem:** Consider a 4-state MDP with states $\mathcal{S} = \{s_1, s_2, s_3, s_4\}$ and actions $\mathcal{A} = \{a, b\}$. Suppose the agent can only observe whether the state is in the set $\{s_1, s_2\}$ or in the set $\{s_3, s_4\}$ (i.e., the $\sigma$-algebra is $\mathcal{F} = \{\emptyset, \{s_1, s_2\}, \{s_3, s_4\}, \mathcal{S}\}$).

**Questions:**
1. How many distinct deterministic policies are $\mathcal{F}$-measurable?
2. What is the structure of the space of stochastic policies measurable with respect to $\mathcal{F}$?
3. Compare with the case of full observability ($\mathcal{F} = 2^{\mathcal{S}}$).

**Solution:**

**Part 1: Deterministic policies with coarse observability**

A deterministic policy $\pi: \mathcal{S} \to \mathcal{A}$ is $\mathcal{F}$-measurable if for every $a \in \mathcal{A}$, the preimage $\pi^{-1}(\{a\}) \in \mathcal{F}$.

Since $\mathcal{A} = \{a, b\}$, we have $\pi^{-1}(\{a\}) \cup \pi^{-1}(\{b\}) = \mathcal{S}$ and these sets are disjoint.

The only sets in $\mathcal{F}$ (besides $\emptyset$ and $\mathcal{S}$) are $\{s_1, s_2\}$ and $\{s_3, s_4\}$.

**Possible measurable policies:**
1. $\pi_1$: $\pi^{-1}(\{a\}) = \emptyset$, $\pi^{-1}(\{b\}) = \mathcal{S}$ $\to$ always choose $b$
2. $\pi_2$: $\pi^{-1}(\{a\}) = \mathcal{S}$, $\pi^{-1}(\{b\}) = \emptyset$ $\to$ always choose $a$
3. $\pi_3$: $\pi^{-1}(\{a\}) = \{s_1, s_2\}$, $\pi^{-1}(\{b\}) = \{s_3, s_4\}$ $\to$ choose $a$ if in first region, $b$ otherwise
4. $\pi_4$: $\pi^{-1}(\{a\}) = \{s_3, s_4\}$, $\pi^{-1}(\{b\}) = \{s_1, s_2\}$ $\to$ choose $a$ if in second region, $b$ otherwise

**Answer:** There are **4 distinct $\mathcal{F}$-measurable deterministic policies**.

**Part 2: Stochastic policies with coarse observability**

A stochastic policy $\pi: \mathcal{S} \times \mathcal{A} \to [0, 1]$ with $\sum_{a' \in \mathcal{A}} \pi(a'|s) = 1$ is $\mathcal{F}$-measurable if $\pi(\cdot | s)$ is constant on each set in $\mathcal{F}$.

That is:
- $\pi(a | s_1) = \pi(a | s_2) = p_1$ for some $p_1 \in [0,1]$
- $\pi(a | s_3) = \pi(a | s_4) = p_2$ for some $p_2 \in [0,1]$

Since $\pi(b|s) = 1 - \pi(a|s)$, the policy is characterized by the pair $(p_1, p_2) \in [0,1]^2$.

**Answer:** The space of $\mathcal{F}$-measurable stochastic policies is isomorphic to the unit square $[0,1]^2$.

**Part 3: Comparison with full observability**

With full observability ($\mathcal{F} = 2^{\mathcal{S}}$, the power set):

**Deterministic policies:** A policy can assign any action to each of the 4 states independently. Thus there are $|\mathcal{A}|^{|\mathcal{S}|} = 2^4 = 16$ distinct deterministic policies.

**Stochastic policies:** A policy is characterized by 4 probabilities $(p_1, p_2, p_3, p_4)$ where $p_i = \pi(a | s_i)$. The space is $[0,1]^4$.

**Summary:**

| Observability | Ïƒ-Algebra | # Deterministic Policies | Stochastic Policy Space |
|---------------|-----------|--------------------------|-------------------------|
| Coarse | $\{\emptyset, \{s_1,s_2\}, \{s_3,s_4\}, \mathcal{S}\}$ | 4 | $[0,1]^2$ |
| Full | $2^{\mathcal{S}}$ | 16 | $[0,1]^4$ |

**Interpretation:** Coarse observability (smaller $\sigma$-algebra) **constrains** the policy class, reducing the number of distinct policies by a factor of 4. This can be beneficial (fewer parameters to learn, better sample complexity) or detrimental (reduced expressiveness, suboptimal performance). The $\sigma$-algebra structure directly determines the **information bottleneck** in the agent's decision-making.

---

## **Reflection: Synthesis of Week 1**

**What We Have Learned:**

1. **Ïƒ-Algebras are the language of observability.** A set $A \subseteq \mathcal{S}$ is observable if and only if $A \in \mathcal{F}$. The $\sigma$-algebra defines the **information structure** of the problem.

2. **Measurable functions preserve structure.** Policies, value functions, and reward functions must be measurable to be compatible with the probabilistic framework. This is not formalismâ€”it is a **physical constraint** on realizability.

3. **Dominated Convergence is the workhorse.** Nearly every convergence proof in RL relies on DCT to justify $\lim \mathbb{E} = \mathbb{E} \lim$. Boundedness assumptions (on rewards, values, gradients) are the dominating functions in these arguments.

4. **CarathÃ©odory constructs measures rigorously.** Transition kernels on continuous spaces are well-defined probability measures only because of the CarathÃ©odory extension. This is the foundation of continuous-state MDPs.

5. **Computation builds intuition.** Implementing $\sigma$-algebra generators and Monte Carlo verification of measurability makes abstract concepts concrete.

**Open Questions for Week 2:**

- How do we define norms on function spaces to quantify "distance" between value functions?
- What is the relationship between different modes of convergence ($L^p$, almost everywhere, in measure)?
- Why is the space $L^\infty(\mathcal{S})$ (bounded functions with supremum norm) the natural home for value functions?

**The Journey Ahead:**

Week 1 has built the **static** language of measurable spaces. Week 2 will make this **dynamic** by constructing $L^p$ spaces and studying convergence in these norms. We are building the function spaces where value functions live and where Bellman operators act.

---

**End of Week 1 Exercises**

ðŸ“… **Next:** Week 2, Day 1 â€“ $L^p$ Spaces and HÃ¶lder's Inequality
